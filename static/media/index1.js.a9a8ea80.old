import React, { Component } from "react";
// import { Link } from "react-router-dom";
// import "./main.scss";
import { connect } from "react-redux";
import makeId from "common/_helpers/makeId";
import Parent from "host/components/Parent";
import difference from "lodash.difference";
import isEqual from "react-fast-compare";
import { utils } from "common/react-grid-layout";
import "./cols.scss";
import type { PropTypes } from "propTypes";
import { withRouter } from "react-router-dom";

import { Resizable, ResizableBox } from "react-resizable";
import { builderConstants } from "common/_redux/_constants";

// import ColumnsChild from "./ColumnsChild";
import { calcXY } from "common/react-grid-layout";
import clonedeep from "lodash.clonedeep";
import {
  whatChanged,
  isEmpty,
  findComponentsWithParent,
  findMinMaxXY,
} from "frontend/Builder/BuilderComponents";
import { checkNested } from "common/_helpers";

import { customizationActions } from "common/_redux/_actions/index";

const layoutMapping = {
  lg: "web",
  md: "tablet",
  sm: "mobile",
};
let props = {
  structure: {
    width: {
      id: "number",
      label: "Columns",
      name: "width",
      default: true,
      value: 1,
    },
    uniqueId: {
      id: "autogenerated",
      visible: false,
    },
  },
  data: {
    columns: {
      type: "ColumnsGallery",
      label:
        "Add columns and set width using the selector below. The sum of the size of all columns shouldn't exceed 12. ",
      info: "Select a row Structure",
    },
    MultiList: {
      type: "MultiListForColumns",

      editType: "Custom",
      viewOn: ["web", "tablet", "mobile"],
      moreOptions: false,
      validation: [
        (array, breakpoint) => {
          if (breakpoint === "web")
            return array.reduce((a, b) => a + (b["width"] || 0), 0) <= 12;
          else return array.filter((a) => a.width > 12).length === 0;
        },
        (array) => {
          let result = true;
          array.map((a) => {
            if (a.width < 1) result = false;
          });
          return result;
        },
        (array) => array.length >= 1 && array.length <= 12,
      ],
    },
  },
};
const prefix = "Column";
const componentStructure = {
  author: "Storylens",
  category: "blocks",
  client_id: prefix + "tkRB",
  components: null,
  context: ["Homepage", "something"],
  custom: false,
  hideIn: [],
  main: "UI/GridLayoutChild/index.js",
  name: prefix,
  type: "block",
};

class ColumnsParent extends React.PureComponent<PropTypes> {
  static defaultProps = {
    componentStyle: {
      global: {
        backgroundColor: "",
        borderRadius: "",
        border: "",
        boxShadow: "",
        opacity: "",
      },
    },
  };
  state = {
    currentBreakpoint: "lg",
    view: "web",

    layouts: {},
    components: [],
    resized: false,
    lazyComponents: [],
    breakpoint: "lg",
    initialRenderComplete: false,
    dragStop: false,

    revision_index: 1,
  };

  shouldComponentUpdate(nextProps, nextState) {
    whatChanged(nextProps, this.props, nextState, this.state, "zom3");
    return true;
  }
  componentWillUnmount() {
    // console.log('deletionStrong ', this.props.client_id, "unmounting")
  }
  async componentDidMount() {
    const { blueprint, client_id } = this.props;
    // console.log('deletionStrong ', client_id, "mounting")
    //Case: Adding the component into the state after initial fetch

    let lazyComponents = [],
      context;

    //Context from store isn't available yet.
    //So, using the value from window in the mean time
    window.location.hash === undefined || window.location.hash === ""
      ? (context = "home")
      : (context = window.location.hash.substr(1));

    let currentPage =
      blueprint && blueprint[context] && blueprint[context].components
        ? blueprint[context].components
        : {};
    currentPage = clonedeep(currentPage);
    let dummyComponentExists =
      Object.getOwnPropertyNames(currentPage).length == 1 &&
      Object.getOwnPropertyNames(currentPage)[0] === "dummComponent";

    if (!dummyComponentExists) {
      try {
        // Do not remove the asyncOutput variable.
        // The asynchronousOutput is used to wait until the async await cycle finishes.
        let asyncOuput = async () => {
          return await Promise.all(
            Object.keys(currentPage)
              .filter((key) => {
                return currentPage[key].parent === client_id;
              })
              .map(async (key) => {
                let component = currentPage[key];
                if (component.wrapper === "true") {
                  component.components.map(async (k, index) => {
                    component["component"][index] = await import(
                      /* webpackMode: "eager" */ `../../${currentPage[key].components[index].main}`
                    );
                  });
                } else {
                  component["component"] = await import(
                    /* webpackMode: "eager" */ `../../${currentPage[key].main}`
                  );
                }
                lazyComponents.push(component);
              })
          );
        };
        this.setState({
          lazyComponents,
          asyncOut: await asyncOuput(),
          components: blueprint[context].components,
          layout_history: [
            {
              layouts: blueprint[context].layouts,
              lazyComponents: lazyComponents,
              components: blueprint[context].components,
            },
          ],
        });
      } catch (err) {
        console.log("error", err);
      }
    }

    // remove href from all <a> inside builder
    const aTags = document.getElementById("slBuilder")
      ? document.getElementById("slBuilder").getElementsByTagName("a")
      : [];
    for (let i = 0; i < aTags.length; i++) {
      aTags[i].href = "";
    }
  }

  async componentDidUpdate(prevProps, prevState) {
    //hack - Remove if this.prevProps isn't used

    if (typeof this.prevProps === "undefined") this.prevProps = {};
    const {
      context,
      client_id,
      blueprint,
      updateProps,
      recentlyremovedComponentId,
      recentlyResizedComp,
      view,
    } = this.props;
    const { currentBreakpoint } = this.state;
    const currentGridCols = blueprint[context].meta.gridLayout.cols;
    const { MultiList } = this.props.componentData || {};

    this.breakpoint = layoutMapping[currentBreakpoint];
    console.log(this.props.componentData, prevProps.componentData, "glitches");

    if (prevProps.view !== view || prevProps.view !== this.state.view) {
      let currentBreakpoint =
        view === "tablet" ? "md" : view === "mobile" ? "sm" : "lg";

      // this.ungroupComponents();
      // this.ungroupComponents();

      this.setState({ currentBreakpoint, view: view });
    }
    if (
      prevProps.isDeletingComponent &&
      !this.props.isDeletingComponent &&
      blueprint[context][client_id]
    ) {
      let layouts = clonedeep(blueprint[context][client_id]);
      layouts[currentBreakpoint] = utils.compact(
        layouts[currentBreakpoint],
        "horizontal",
        currentGridCols[currentBreakpoint]
      );

      layouts[currentBreakpoint] = layouts[currentBreakpoint].map((i) => {
        i.y = 0;
        return i;
      });
      this.props.saveLayout(layouts, client_id);
      if (typeof recentlyremovedComponentId === "string") {
        setTimeout(() => {
          this.setState((prevState) => {
            return {
              lazyComponents: prevState.lazyComponents.filter((item) => {
                return item.client_id !== recentlyremovedComponentId;
              }),
            };
          });
        }, 11);
      }
    }
    //Addition of newer columns
    else if (
      (!prevProps.componentData &&
        checkNested(
          this.props.componentData,
          "MultiList",
          this.breakpoint,
          "length"
        ) &&
        this.props.componentData.MultiList[this.breakpoint].length > 0) ||
      (checkNested(
        prevProps.componentData,
        "MultiList",
        this.breakpoint,
        "length"
      ) &&
        checkNested(
          this.props.componentData,
          "MultiList",
          this.breakpoint,
          "length"
        ) &&
        prevProps.componentData.MultiList[this.breakpoint].length <
          this.props.componentData.MultiList[this.breakpoint].length)
    ) {
      let x = 0;
      for (let i = 0; i <= MultiList[this.breakpoint].length - 1; i++) {
        x = MultiList[this.breakpoint][i].width + x;
      }
      let latestOne = MultiList[this.breakpoint].filter((item) => item.latest);
      let clone;
      if (this.breakpoint === "web") {
        clone = { ...MultiList };
        clone = {
          ...clone,
          tablet: [...(clone.tablet || []), latestOne[0]],
          mobile: [...(clone.mobile || []), latestOne[0]],
        };

        updateProps(
          { componentData: { MultiList: clone } },
          client_id,
          context
        );
      }
      let data = {
        ...componentStructure,
        parent: client_id,
      };
      //GRID DENSITY HARDCODED AS 100 HERE.
      let component = {
        context: context,
        data: data,
        x: Math.ceil(((x - 1) / 12) * currentGridCols[currentBreakpoint]),
        y: 0,
        w: (Number(latestOne[0].width) / 12) * 20,
      };
      let randomWord = latestOne[0].uniqueId || makeId(4);
      //Timeout so that it doesn't conflict with the update props option
      setTimeout(() => {
        this.props.updateBlueprint(component, randomWord, context);
      }, 5);
    }

    //Deletion of a column
    else if (
      checkNested(
        prevProps.componentData,
        "MultiList",
        this.breakpoint,
        "length"
      ) &&
      prevProps.componentData.MultiList[this.breakpoint].length >
        this.props.componentData.MultiList[this.breakpoint].length
    ) {
      let newIds = MultiList[this.breakpoint].map(
        (item) => prefix + item.uniqueId
      );
      let childComponents = Object.keys(blueprint[context].components).filter(
        (item) => blueprint[context].components[item].parent === client_id
      );
      let componentToBeRemoved = difference(childComponents, newIds)[0];
      console.log(componentToBeRemoved, "glitches1");
      this.props.removeComponent(componentToBeRemoved, context);
      let clone;

      if (this.breakpoint === "web") {
        clone = { ...MultiList };
        clone = {
          ...clone,
          tablet: [
            ...(clone.tablet || []).filter(
              (item) => item.uniqueId !== componentToBeRemoved.substr(-4)
            ),
          ],
          mobile: [
            ...(clone.tablet || []).filter(
              (item) => item.uniqueId !== componentToBeRemoved.substr(-4)
            ),
          ],
        };
        console.log(clone, "glitch5");

        // updateProps(
        //   { componentData: { MultiList: clone } },
        //   client_id,
        //   context,

        // );
      }
    } else if (
      prevProps.recentlyResizedComp === client_id &&
      recentlyResizedComp === ""
    ) {
      //When the outer component gets resized
      const { screenWidth, client_id, documentContext, view } = this.props;
      const _doc = documentContext || document;
      const { offsetHeight, offsetWidth } = _doc.getElementById(client_id);
      const { x, y } = calcXY(offsetHeight, offsetWidth, {
        ...blueprint[context].meta.gridLayout,
        containerWidth: screenWidth - builderConstants.CANAS_SCREEN_SIZE_OFFSET - builderConstants.CANVAS_SCREEN_SIZE_PADDING_OFFSET,
        cols:
          blueprint[context].meta.gridLayout.cols[this.state.currentBreakpoint],
      });
      let layouts = clonedeep(blueprint[context][client_id]);
      if (layouts) {
        layouts[currentBreakpoint].map((item) => {
          item.h = y;
          item.y = 0;
        });
        this.props.saveLayout(layouts, client_id);
      }
    }
    //When the props are changed via the right side dock
    else if (
      !isEqual(prevProps.componentData, this.props.componentData) &&
      blueprint[context][client_id]
    ) {
      let layouts = clonedeep(blueprint[context][client_id]);

      let latestOne = MultiList[this.breakpoint].filter((item) => item.latest);

      let index;
      layouts[currentBreakpoint].some((x, i) => {
        if (x.i === prefix + latestOne[0].uniqueId) return (index = i);
        // else return -99;
      });
      console.log(
        latestOne,
        layouts[currentBreakpoint],
        index,
        client_id,
        prefix,
        "glitches"
      );

      layouts[currentBreakpoint][index].w = Math.floor(
        (Number(latestOne[0].width) / 12) * currentGridCols[currentBreakpoint]
      );
      layouts[currentBreakpoint] = utils.compact(
        layouts[currentBreakpoint],
        "horizontal",
        currentGridCols[currentBreakpoint]
      );
      // layouts[currentBreakpoint] = layouts[currentBreakpoint].map(
      //   (i) => (i.y = 0)
      // );
      this.props.saveLayout(layouts, client_id);

      // this.setState((prevState) => {
      //   return {
      //     lazyComponents: prevState.lazyComponents.map((item) => {
      //       item.props = {
      //         ...item.props,
      //         ...MultiList.filter(
      //           (i) => prefix + i.uniqueId === item.client_id
      //         )[0],
      //       };
      //       console.log(
      //         item,
      //         "zom3",
      //         MultiList,
      //         item.client_id,
      //         MultiList.filter((i) => {
      //           console.log("zom3", prefix + i.uniqueId, item.client_id);
      //           return prefix + i.uniqueId === item.client_id;
      //         })[0]
      //       );
      //       return item;
      //     }),
      //   };
      // });
    }
    this.prevProps = prevProps;
    let {
      isUpdatingBluePrint,
      recentlyAddedComponent,
      deletionKey,
      updateComplete,
    } = this.props;

    if (
      !prevProps.isUpdatingBluePrint &&
      isUpdatingBluePrint &&
      recentlyAddedComponent
    ) {
      recentlyAddedComponent = clonedeep(recentlyAddedComponent);
      let updateRequired = false;
      let updatedLazyComponents = [];
      const { lazyComponents } = this.state;
      let currentPage =
        blueprint && blueprint[context].components
          ? blueprint[context].components
          : {};
      // currentPage = JSON.parse(JSON.stringify(currentPage));
      let multipleComponentsAdded =
        Object.getOwnPropertyNames(recentlyAddedComponent).length > 1;
      if (!multipleComponentsAdded) {
        let newComponent = Object.getOwnPropertyNames(
          recentlyAddedComponent
        )[0];
        currentPage[newComponent] = recentlyAddedComponent[newComponent];
        let component = currentPage[newComponent];

        if (
          component &&
          typeof component.parent === "string" &&
          component.parent === client_id
        ) {
          if (!lazyComponents.some((e) => e.client_id === newComponent)) {
            if (component.wrapper === "true") {
              component.components.map(async (k, index) => {
                index === 0 ? (component["component"] = []) : null;
                component["component"][index] = await import(
                  /* webpackMode: "eager" */ `../../${currentPage[newComponent].components[index].main}`
                );
              });
            } else {
              component["component"] = await import(
                /* webpackMode: "eager" */ `../../${currentPage[newComponent].main}`
              );
            }
            setTimeout(() => {
              this.setState(
                (prevState) => ({
                  lazyComponents: [...prevState.lazyComponents, component],
                }),
                () => {
                  this.props.updateComplete(2, this.props.client_id);
                }
              );
            }, 50);
          } else {
            this.setState(
              {
                lazyComponents: lazyComponents.map((el) =>
                  el.client_id === newComponent
                    ? Object.assign({}, el, {
                        props: component.props,
                        zIndex: component.zIndex,
                      })
                    : el
                ),
              },
              () => updateComplete(3, this.props.client_id)
            );
          }
        } else if (
          component &&
          ((typeof component.parent === "string" &&
            component.parent !== client_id &&
            deletionKey === "DONOR_TO_HOST") ||
            (typeof component.parent === "undefined" &&
              deletionKey === "DONOR_TO_CANVAS"))
        ) {
          let name = Object.getOwnPropertyNames(recentlyAddedComponent)[0];

          this.setState(
            (prevState) => {
              return {
                lazyComponents: prevState.lazyComponents.filter((item) => {
                  return item.client_id !== name;
                }),
              };
            },
            () => {
              updateComplete(4, this.props.client_id);
            }
          );
        }
      } else {
        console.log(this.props.componentData, "columnStrong");

        // let props = {

        // }
        // let dataToBeStored = {
        //   context: context,
        //   client_id: client_id,
        //   props: props
        // }
        // this.props.updateComponentProps(dataToBeStored);

        console.log("columnStrong", this.props.componentData);
        let componentArray = [];
        //ungroup Use case - A duplicate of the previous usecase with single component
        Object.keys(recentlyAddedComponent).map(async (newComponent, index) => {
          currentPage[newComponent] = recentlyAddedComponent[newComponent];
          let component = currentPage[newComponent];
          if (
            component &&
            typeof component.parent === "string" &&
            component.parent === client_id
          ) {
            if (!lazyComponents.some((e) => e.client_id === newComponent)) {
              if (component.wrapper === "true") {
                component.components.map(async (k, index) => {
                  if (index === 0) {
                    component["component"] = [];
                  }
                  component["component"][index] = await import(
                    /* webpackMode: "eager" */ `../../${currentPage[newComponent].components[index].main}`
                  );
                });
                componentArray.push(component);
              } else {
                component["component"] = await import(
                  /* webpackMode: "eager" */ `../../${currentPage[newComponent].main}`
                );

                componentArray.push(component);
              }
            } else {
              updateRequired = true;

              if (index === 0)
                updatedLazyComponents = lazyComponents.filter((e) => {
                  return e.client_id != newComponent;
                });
              else
                updatedLazyComponents = updatedLazyComponents.filter((e) => {
                  return e.client_id != newComponent;
                });

              component["component"] = await import(
                /* webpackMode: "eager" */ `../../${currentPage[newComponent].main}`
              );
              componentArray.push(component);
            }
          }
        });
      }
    }
  }
  toggleEditOption = () => {
    console.log("toggle");
  };

  calculateChildrenHeight = () => {
    const { blueprint, context, client_id } = this.props;
    const { currentBreakpoint } = this.state;
    let children = findComponentsWithParent(blueprint[context], client_id);
    if (!children || children.length === 0) return;
    let layouts = {},
      minMaxXY = {},
      height = {};
    let rowHeight = blueprint[context].meta.gridLayout.rowHeight;
    for (var i = 0; i < children.length; i++) {
      layouts[children[i]] =
        blueprint[context][children[i]] &&
        blueprint[context][children[i]][currentBreakpoint];
      minMaxXY[children[i]] = findMinMaxXY(layouts[children[i]]);
      height[children[i]] =
        minMaxXY[children[i]] && minMaxXY[children[i]].maxY * rowHeight;
    }
    this.height = height;

    console.log(layouts, minMaxXY, height, rowHeight, "zoor");
  };
  render() {
    const {
      componentStyle,
      componentData,
      client_id,
      view,
      blueprint,
      context,
      documentContext,
    } = this.props;
    const { lazyComponents, currentBreakpoint } = this.state;
    this.breakpoint = layoutMapping[currentBreakpoint];
    const { global } = componentStyle;
    const MultiList =
      (componentData && componentData.MultiList[this.breakpoint]) || [];
    let objects;
    let highestSize = 0;
    if (!isEmpty(MultiList))
      objects = Object.assign(
        {},
        ...MultiList.map((item) => {
          if (item.width > highestSize) highestSize = item.width;
          return { [prefix + item.uniqueId]: item };
        })
      );

    // console.log(clonedeep(blueprint[context].components[client_id]), objects, MultiList, componentData, "zom3");
    const breakpointStyles =
      this.breakpoint !== "web" && highestSize === 12
        ? { height: "fit-content", minHeight: "100px" }
        : { height: "inherit" };
    let currentHeight = this.calculateChildrenHeight();
    console.log(
      MultiList,
      this.breakpoint,
      componentData,
      layoutMapping,
      objects,
      "exchangee1"
    );
    return (
      <div
        class="columns-parent row-sl rgl-container"
        id={client_id + "-childSection"}
        // className="rgl-container"
        style={{ ...global, ...breakpointStyles }}
      >
        {lazyComponents
          .filter((component) => {
            if (typeof component.hideIn === "undefined") return true;
            else
              return (
                component.hideIn &&
                !component.hideIn.includes(this.state.currentBreakpoint)
              );
          })
          .map((component, index) => {
            const Component = component.component.default;
            const compProps = component.props;
            //
            if (objects) {
              return (
                <div
                  id={`${component.client_id}`}
                  style={{
                    height: "100%",
                    minHeight: this.height[component.client_id]
                      ? this.height[component.client_id] + "px"
                      : "100px",
                  }}
                  className={`${
                    objects && objects[component.client_id]
                      ? `col-sl-${objects[component.client_id].width}${
                          this.breakpoint === "mobile" ? "-sm" : ""
                        }`
                      : `col-sl-1${this.breakpoint === "mobile" ? "-sm" : ""}`
                  }`}
                  key={`${component.client_id}`}
                >
                  <Parent
                    key={`${component.client_id} `}
                    width={
                      objects[component.client_id] &&
                      objects[component.client_id].width
                    } // onScreenCapture={onStartCapture}
                    screenPosition={this.state.elementScreenPosition}
                    // dragElement={currentlyDraggedElement}
                    clientId={component.client_id.toString()}
                    view={view}
                    type={component.type}
                    category={component.category}
                    component={component}
                    className={""}
                    toggleEditOption={(e) => this.toggleEditOption(e)}
                    // onEdit={this.onComponentEdit}
                    // windowContext={windowContext}
                    // documentContext={documentContext}
                    zIndex={component.zIndex}

                    // might need change (responsive)
                  >
                    <ResizableBox
                      width={200}
                      height={200}
                      minConstraints={[100, 100]}
                      maxConstraints={[300, 300]}
                    >
                      <Component
                        key={component.client_id}
                        obj={objects[component.client_id]}
                        width={
                          objects[component.client_id] &&
                          objects[component.client_id].width
                        }
                        documentContext={documentContext}
                        clientId={component.client_id}
                        client_id={component.client_id}
                        columnsId={client_id}
                        // {...compProps}
                      />
                    </ResizableBox>
                  </Parent>
                </div>
              );
            }
          })}
      </div>
    );
  }
}

const mapStateToProps = (state) => {
  return {
    isUpdatingBluePrint: state.admin.customization.present.isUpdatingBluePrint,
    isDeletingComponent: state.admin.customization.present.isDeletingComponent,
    recentlyAddedComponent:
      state.admin.customization.present.data.recentlyAddedComponent,
    recentlyremovedComponentId:
      state.admin.customization.present.data.recentlyremovedComponentId,
    recentlyResizedComp: state.admin.customization.present.recentlyResizedComp,

    selectedComponent:
      state.admin.customization.present.data.currentlySelectedComponentId,
    context: state.admin.customization.present.context,
    blueprint: state.admin.customization.present.data.blueprint,
    view: state.admin.customization.present.data.view,
    screenWidth: state.ui.screenWidth,
  };
};

const mapDispatchToProps = (dispatch) => {
  return {
    updateBlueprint: (component, randomWord, mode) => {
      dispatch(
        customizationActions.updateBlueprint(component, randomWord, mode)
      );
    },
    updateComplete: (a) => {
      console.log(a, "zom2");
      dispatch(customizationActions.blueprintAndLayoutUpdateComplete());
    },
    removeComponent: (clientId, context) =>
      dispatch(customizationActions.removeComponent(clientId, context)),
    updateProps: (props, selectedComponent, context, zIndex) => {
      let data = {
        client_id: selectedComponent,
        context: context,
        props: props,
      };
      dispatch(customizationActions.updateComponentProps(data));
    },
    saveLayout: (layout, parent_id) => {
      // saveToLS("hero", layout);
      console.log("drone2");
      dispatch(customizationActions.saveLayoutToServer(layout, parent_id));
    },
  };
};

const ConnectedComponent = withRouter(
  connect(
    mapStateToProps,
    mapDispatchToProps
  )(ColumnsParent)
);
export default ConnectedComponent;
ConnectedComponent.getMetadata = () => {
  return props;
};

//  console.log(
//     this.props.componentData,
//     prevProps.componentData,
//     this.prevProps,
//     !prevProps.componentData &&
//       this.props.componentData &&
//       this.props.componentData.MultiList.length > 0,
//     prevProps.componentData &&
//       prevProps.componentData.MultiList.length <
//         this.props.componentData.MultiList.length,
//     "zom"
//   );
